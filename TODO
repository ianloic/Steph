# Union types
need these for interesting lists and pattern matching?

# List types

type names:
List() - empty list
List(Type) - list of Type

literals:
[] - empty list
[expression, expression, expression] - list


# Pattern matching functions
must always have the same # of args.
must always have a "default" matcher? how to ensure coverage of inputs?


let factorial : (Number)=>Number =
    (1) => 1
    (n) => factorial(n-1) * n;


let sum : (List(Number)) => number =
    ([]) => 0
    ([x:xs] : List(Number)) => x + sum(xs)



# errors or exceptions?